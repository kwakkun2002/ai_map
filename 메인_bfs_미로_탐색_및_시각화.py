# -*- coding: utf-8 -*-
"""메인 BFS 미로 탐색 및 시각화

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1AJuU4jQWnjiwfT1ZQKlBtYcuzfVVJ--N
"""

import collections
import time
import math
import matplotlib.pyplot as plt
import numpy as np
from IPython.display import Image, display, Markdown
import os

"""1. 미로 맵 데이터"""

SAMPLE_MAZE_DATA = [
    '111111111111111111111111111111111111111111111111111111111111',
    '1S0110001111111011101001101110000101100010111111101111000101',
    '110001000111110010101111110110111100111010010011011100111001',
    '110010101111000110011100111101110110011111111101001101101101',
    '100001100011101111110101100000111111010110010110110111010111',
    '110000110111010110110110011100011000001010011111001011001111',
    '110010111100101111000011100101000001010000101001011011110011',
    '100010101011101011110101000110110011111110000111111011110011',
    '101000001111101101011010011101110100010000101001110010111111',
    '100000001111010001110001010111110111101111011111101001111011',
    '100000000101100100100111001010010001001111100100001001011101',
    '110000000110110100110101000101101111101011111101110011111111',
    '111010000011111010110111101000111100100001101111111100100001',
    '100110000110111000111111110010001101001101111001010011110111',
    '100111100011010100111110011010110011101001010101110111111111',
    '110110100010001111001110101101000001100011000011001001011111',
    '110110010000000000111011011111101001100101010010000000001111',
    '101101110100100000001000000101110010011101011001110111011001',
    '101011111011100101000010100110111101101101011110110111101011',
    '101110100110111010110010110110100000111111110110101100111111',
    '110000001110110101000000100110111011101011110011110010111011',
    '111010111111111101100001011001101111000010111111111110100011',
    '111000101001010000110000111101000111001001111101011111111111',
    '111001101000011110010000000000101111101111010001101110001111',
    '101110111010100111100000001100101011011111110110000110010111',
    '111010111111011011110000001011101110011010000111010100010111',
    '111101011011001110001011000010011101010110101001010001001101',
    '111100010111011011111101000010110011110000001111011101011001',
    '110010010100010101111101000101111110100001011010010101010011',
    '111111010000111111111101010010111110101111001101000111111101',
    '110010101001111111101101000001010100100011000101100010101111',
    '110100001111011101100000111001110110011010000110111111001011',
    '110101101011010011010011100010100110000111010110011111110011',
    '101000110111111001010011111001101011100111101100110111111111',
    '111111101111100100111100100000001010010010111101111011011101',
    '101010011111010111011100100011011100001100001111010100010111',
    '111000101100010011010100100001010111111101001111110111110101',
    '101000110101010110000101011000011111110100001111101111101001',
    '100011111111010111100111001101010011110101010010110100101101',
    '111010010001100011111111111001111111000111111111111101111011',
    '100110001101100101111011111010000000011010001011100101010101',
    '101010010011111111101111110000101111011010001011110111011011',
    '111010011011110101011000010111100111110000111111111001101011',
    '111011111001110010101010010110100101100111111111011000100001',
    '101010000111110011101011000101110001011111011011011010101011',
    '101101110100111101000111101101001001101001100110110111110001',
    '100011101100111110001011000011111000110110111101100010001111',
    '110100100101001101001011011111111100000001110010011101111011',
    '100011101111110111010011111000100011111000001010111011101111',
    '100011110111111011111000101111101011101100100101001101101101',
    '101111101101111010111111110100000111011110001010001010010101',
    '101001100010011100111111110110001110000010100010000100001111',
    '110100010010001101010101000111111110001111100001011011101011',
    '110110101111000111110111100111110111011101111101001110110011',
    '110101100100001010001101000100111111000111110000111111101111',
    '100101100010111010101011011000001111100110011000000001110111',
    '110001111000011100100011010011111001110010011100010001000001',
    '100000111101101100010001111001011101011101010101011001110011',
    '1100101011010101001011111101001011111011011001011000000000G1',
    '111111111111111111111111111111111111111111111111111111111111'
]

print("Setup Complete.")

"""유틸리티 함수 정의 (맵 처리 및 경로 복원)

이 셀에는 미로 데이터를 처리하고, 이웃 노드를 찾고, 최종 경로를 역추적하는 데 사용되는 함수들이 포함.
"""

def normalize_maze_structure(maze_data):
    """
    미로의 문자열 데이터 리스트를 받아, 모든 행 길이를 가장 긴 행의 길이로 통일하고
    문자 리스트의 리스트 (2D array)로 변환합니다. 짧은 행은 벽('1')으로 채웁니다.
    """
    if not maze_data:
        return []

    maze = [list(row) for row in maze_data]
    max_cols = max(len(row) for row in maze)

    normalized_maze = []
    for row in maze:
        current_len = len(row)
        padding_needed = max_cols - current_len
        padded_row = row + ['1'] * padding_needed
        normalized_maze.append(padded_row)

    return normalized_maze

def find_start_goal(maze):
    """미로에서 시작점 'S'와 목표점 'G'의 좌표를 찾습니다."""
    start = None
    goal = None
    rows = len(maze)
    cols = len(maze[0])

    for r in range(rows):
        for c in range(cols):
            if maze[r][c] == 'S':
                start = (r, c)
            elif maze[r][c] == 'G':
                goal = (r, c)

    return start, goal

def get_neighbors(maze, current_node):
    """현재 노드에서 이동 가능한 (벽이 아닌) 인접 노드를 반환합니다."""
    rows = len(maze)
    cols = len(maze[0])
    r, c = current_node

    # 상, 하, 좌, 우 4방향 이동
    moves = [(-1, 0), (1, 0), (0, -1), (0, 1)]
    neighbors = []

    for dr, dc in moves:
        nr, nc = r + dr, c + dc  # 새 행/열 좌표

        # 미로 경계 확인 및 벽('1')이 아닌지 확인
        if 0 <= nr < rows and 0 <= nc < cols and maze[nr][nc] != '1':
            neighbors.append((nr, nc))

    return neighbors

def reconstruct_path(parent, start, goal):
    """부모 포인터(parent) 딕셔너리를 이용해 목표점에서 시작점까지 경로를 역추적합니다."""
    path = []
    current = goal

    # 목표점에서 시작점까지 역순으로 이동
    while current != start:
        path.append(current)
        if current in parent:
            current = parent[current]
        else:
            return [] # 경로를 찾지 못한 경우
    path.append(start)
    path.reverse()
    return path

print("Utility Functions Loaded.")

"""탐색 알고리즘 정의 (BFS)

이 셀에는 최단 경로 탐색을 보장하는 BFS(Breadth-First Search) 알고리즘이 구현되어 있습니다.
"""

def bfs_search(maze, start, goal):
    """너비 우선 탐색 (BFS) 구현: 최단 경로 보장"""
    queue = collections.deque([start])
    visited = {start}
    parent = {start: None}
    visited_history = [start] # 시각화용
    expanded_nodes = 0

    while queue:
        current_node = queue.popleft()
        expanded_nodes += 1

        if current_node == goal:
            path = reconstruct_path(parent, start, goal)
            return path, expanded_nodes, visited_history

        for neighbor in get_neighbors(maze, current_node):
            if neighbor not in visited:
                visited.add(neighbor)
                parent[neighbor] = current_node
                queue.append(neighbor)
                visited_history.append(neighbor)

    return None, expanded_nodes, visited_history

print("BFS Algorithm Defined.")

"""시각화 함수 정의 및 Colab 출력 로직

이 셀에는 탐색 결과를 Matplotlib으로 시각화하고, 결과를 파일로 저장한 후 Colab에 이미지로 출력하는 함수가 정의되어 있습니다.
"""

def visualize_maze(maze, path, visited_history, start, goal, filename):
    """
    미로 탐색 결과를 시각화하고 이미지 파일로 저장한 후 Colab에 출력합니다.
    """
    rows = len(maze)
    cols = len(maze[0])

    # 맵 초기화: 0(길), 1(벽)
    grid = np.zeros((rows, cols))
    for r in range(rows):
        for c in range(cols):
            if maze[r][c] == '1':
                grid[r][c] = 1 # 벽

    # 방문했던 노드 표시 (밝은 녹색: 2)
    for r, c in visited_history:
        if grid[r][c] == 0:
             grid[r][c] = 2

    # 최종 경로 표시 (노란색: 3)
    for r, c in path:
        if (r, c) != start and (r, c) != goal:
            grid[r][c] = 3

    # 시작점과 목표점 표시 (파란색: 4, 빨간색: 5)
    grid[start[0]][start[1]] = 4
    grid[goal[0]][goal[1]] = 5

    # --- 색상 스키마 변환 (요청된 검은색 배경/흰색 길) ---
    transformed_grid = np.zeros_like(grid)
    for r in range(rows):
        for c in range(cols):
            val = grid[r][c]
            if val == 0:  # 원본 0 (길) -> 요청 1 (흰색)
                transformed_grid[r][c] = 1
            elif val == 1: # 원본 1 (벽) -> 요청 0 (검은색)
                transformed_grid[r][c] = 0
            else:
                transformed_grid[r][c] = val

    # 색상 맵 정의 (0:검은색(벽), 1:흰색(길), 2:초록색(방문), 3:노란색(경로), 4:파란색(시작), 5:빨간색(목표))
    colors = ['black', 'white', 'lightgreen', 'yellow', 'blue', 'red']
    cmap = plt.cm.colors.ListedColormap(colors)
    bounds = [-0.5, 0.5, 1.5, 2.5, 3.5, 4.5, 5.5]
    norm = plt.cm.colors.BoundaryNorm(bounds, cmap.N)

    # 그림 설정 및 저장
    fig, ax = plt.subplots(figsize=(cols/10, rows/10), dpi=300)
    ax.imshow(transformed_grid, cmap=cmap, norm=norm, origin='upper')

    # 격자선 및 기타 설정
    ax.set_xticks(np.arange(-0.5, cols, 1), minor=True)
    ax.set_yticks(np.arange(-0.5, rows, 1), minor=True)
    ax.grid(which="minor", color="gray", linestyle='-', linewidth=0.1)
    ax.tick_params(which="minor", size=0)
    ax.tick_params(which="major", bottom=False, left=False, labelbottom=False, labelleft=False)

    plt.title(f"{filename.split('.')[0]} (BFS Result)", fontsize=10)
    plt.tight_layout()

    # 이미지 파일 저장 (Colab 인스턴스의 로컬 경로)
    plt.savefig(filename, dpi=300)
    plt.close(fig) # 메모리 해제

    # Colab에서 파일을 로드하여 출력
    # 1. 파일 링크 출력 (Colab에서 다운로드 가능)
    display(Markdown(f"### [결과 이미지 다운로드: {filename}](/{filename})"))

    # 2. 이미지를 화면에 직접 렌더링
    display(Image(filename=filename))

    return f"결과 이미지 저장 및 출력 완료: {filename}"

print("Visualization Function Defined.")

"""메인 실행 블록 (전체 프로젝트 실행)

이 셀을 실행하면 BFS 탐색을 시작하고, 콘솔에 성능 지표가 출력되며, 최종적으로 시각화된 경로 이미지를 화면에 띄웁니다.
"""

def run_project():
    # 1. 미로 구조 정규화 및 시작/목표점 찾기
    maze = normalize_maze_structure(SAMPLE_MAZE_DATA)
    start, goal = find_start_goal(maze)

    if not start or not goal:
        print("오류: 미로에서 시작점(S) 또는 목표점(G)을 찾을 수 없습니다.")
        return

    print("--- 미로 탐색 에이전트 (BFS 단일) 실행 ---")
    print(f"맵 크기: {len(maze)}x{len(maze[0])}")
    print(f"시작점: {start}, 목표점: {goal}\n")

    # 2. BFS 탐색 실행 및 성능 측정
    search_func = bfs_search

    print("--- 탐색 알고리즘: BFS (너비 우선 탐색) ---")
    start_time = time.time()
    path, expanded_nodes, visited_data = search_func(maze, start, goal)
    end_time = time.time()


    path_length = len(path) - 1 if path else "경로 없음"
    execution_time = end_time - start_time

    print(f"탐색 완료: {'성공' if path else '실패'}")
    print(f"경로 길이: {path_length}")
    print(f"확장 노드 수: {expanded_nodes}")
    print(f"탐색 시간: {execution_time:.4f} 초\n")


    # 3. BFS 결과 시각화 (요구사항: result_path.png)
    if path:
        filename = "result_path.png"
        visualize_maze(
            maze,
            path,
            visited_data,
            start,
            goal,
            filename
        )

    else:
         print("최단 경로를 찾지 못하여 시각화를 수행할 수 없습니다.")


if __name__ == '__main__':
    run_project()