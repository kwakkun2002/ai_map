# -*- coding: utf-8 -*-
"""ai.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1X1aqQDBjLIKqhYf2Dd8C0cERPXlrvXr0
"""

import heapq
import numpy as np
import matplotlib.pyplot as plt
import math

from google.colab import drive
drive.mount('/content/drive')

MAP_PATH = '/content/drive/MyDrive/maze_map.txt'
NEIGHBORS = [(1,0), (-1,0), (0,1), (0,-1)]

"""maze_map.txt를 그리드로 변환"""

def read_map(map_path):
    """
    파일에서 그리드를 읽어옴
    """
    with open(map_path, 'r', encoding='utf-8') as f:
        grid = []
        start = None
        goal = None
        for row, line in enumerate(f):
            single_row = line.strip()
            for col, cell in enumerate(single_row):
                if cell == "S":
                    start = (row, col)
                elif cell == "G":
                    goal = (row, col)
            grid.append(list(single_row))
    return grid, start, goal

def grid_to_numeric(grid):
    """
    그리드를 숫자로 변환
    """
    h = len(grid)
    w = len(grid[0])
    arr = np.zeros((h, w))

    for y in range(h):
        for x in range(w):
            if grid[y][x] == '1': arr[y, x] = 1 # wall
            elif grid[y][x] == '0': arr[y, x] = 0  # path
            elif grid[y][x] == 'S': arr[y, x] = 2  # start
            elif grid[y][x] == 'G': arr[y, x] = 3  # goal
            elif grid[y][x] == 'V': arr[y, x] = 4 # visited
            elif grid[y][x] == 'X': arr[y, x] = 5  # optimal path
            else: arr[y, x] = 5 # unknown

    return arr

def print_grid(grid):
    """
    그리드를 콘솔에 출력
    """
    print("Printing grid:")
    print("Grid Size: ", len(grid), "x", len(grid[0]))
    for row in grid:
        print(" ".join(row))

def save_map_image(arr, save_path):
    """
    숫자로 변환된 그리드를 이미지로 저장
    """
    cmap = {
        0: (1,1,1),      # path: white
        1: (0,0,0),      # wall: black
        2: (0.2,0.4,1),  # start: blue
        3: (1,0.2,0.2),  # goal: red
        4: (0,1,0),      # visited: green
        5: (1,1,0),       # optimal path: yellow
        6: (0.5,0.5,0.5), # unknown: gray
    }

    rgb = np.zeros((arr.shape[0], arr.shape[1], 3))
    for y in range(arr.shape[0]):
        for x in range(arr.shape[1]):
            rgb[y, x] = cmap[arr[y, x]]

    plt.imshow(rgb)
    plt.axis('off')

    plt.savefig(save_path, dpi=300, bbox_inches='tight', pad_inches=0)
    plt.close()

def is_valid(grid, row, col):
    """
    이동할 수 있는 여부 확부
    """
    if row < 0 or row >= len(grid): return False
    if col < 0 or col >= len(grid[0]): return False
    if grid[row][col] == "1": return False
    return True

def neighbors(grid, row, col):
    """
    이동할 수 있는 이웃 좌표 반환
    """
    for n_row, n_col in NEIGHBORS:
        if is_valid(grid, row+n_row, col+n_col):
            yield (row+n_row, col+n_col)

"""# 휴리스틱 함수들"""

def manhattan_distance_heuristic(a, b):
    return abs(a[0] - b[0]) + abs(a[1] - b[1])

def manhattan_tie_breaking_heuristic(a, b):
    dx = abs(a[0] - b[0])
    dy = abs(a[1] - b[1])
    # 기본 멘해튼 거리에 0.1%의 가중치를 더함 -> 같은 경로가 많아 탐색이 느려지는 것을 방지
    return (dx + dy) * 1.001

def euclidean_heuristic(a, b):
    # 피타고라스 정리: sqrt((x1-x2)^2 + (y1-y2)^2)
    return math.sqrt((a[0] - b[0])**2 + (a[1] - b[1])**2)

"""# A* 알고리즘

"""

def astar(grid, start, goal, heuristic):
    """
    A* 알고리즘으로 경로 찾기
    """
    open_set = []
    heapq.heappush(open_set, (0, 0, start, [start]))

    visited = set()

    while open_set:
        f, g, current, path = heapq.heappop(open_set)

        if current in visited:
            continue
        visited.add(current)

        if current == goal:
            return path, visited

        for neighbor in neighbors(grid, current[0], current[1]):
            if neighbor in visited:
                continue

            new_g = g + 1
            h = heuristic(neighbor, goal)
            f_score = new_g + h

            heapq.heappush(open_set, (f_score, new_g, neighbor, path + [neighbor]))

    return None, visited

"""# Greedy 알고리즘"""

def greedy(grid, start, goal, heuristic):
    start_h = heuristic(start, goal)
    open_set = []
    heapq.heappush(open_set, (start_h, 0, start, [start]))

    visited = set()

    while open_set:
        h, g, current, path = heapq.heappop(open_set)

        if current in visited:
            continue
        visited.add(current)

        if current == goal:
            return path, visited

        for neighbor in neighbors(grid, current[0], current[1]):
            if neighbor in visited:
                continue
            new_g = g + 1
            new_h = heuristic(neighbor, goal)
            heapq.heappush(open_set, (new_h, new_g, neighbor, path + [neighbor]))

    return None, visited

"""실행기"""

def run_algorithm(name, algorithm, png_save_path, heuristic):
  grid, start, goal = read_map(MAP_PATH)
  print(name + " 알고리즘을 실행합니다.")
  print("start: ", start)
  print("goal: ", goal)

  path, visited = algorithm(grid, start, goal, heuristic)

  print(str(len(visited)) + "개의 노드를 방문했습니다.")
  print("발견 경로의 Cost는 " + str(len(path)) + "입니다. ")

  for y, x in visited:
      grid[y][x] = 'V'

    # 2. 최적 경로 표시
  for y, x in path[1:-1]:
      grid[y][x] = 'X'

  grid[start[0]][start[1]] = 'S'
  grid[goal[0]][goal[1]] = 'G'

  # 그리드를 숫자 배열로 변환 후 이미지로 저장
  arr = grid_to_numeric(grid)
  save_map_image(arr, png_save_path)

run_algorithm("astar", astar, "astar_result_manhattan", manhattan_distance_heuristic)

run_algorithm("greedy", greedy, "greedy_result_manhattan", manhattan_distance_heuristic)

run_algorithm("astar", astar, "astar_result_euclidean", euclidean_heuristic)

run_algorithm("greedy", greedy, "greedy_result_euclidean", euclidean_heuristic)

run_algorithm("astar", astar, "astar_result_tie_breaking", manhattan_tie_breaking_heuristic)

run_algorithm("greedy", greedy, "greedy_result_tie_breaking", manhattan_tie_breaking_heuristic)